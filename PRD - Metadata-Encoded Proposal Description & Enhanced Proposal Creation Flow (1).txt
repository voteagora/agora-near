Product Requirements Document (PRD)
Feature: Metadata-Encoded Proposal Description & Enhanced Proposal Creation Flow
Document Version
* Author: Jeffrey McLarty, Agora

* Date: 2025-12-09

* Version: 1.0

________________


1. Overview
This PRD specifies a small enhancement to the proposal creation flow and corresponding result calculation. The work introduces a new metadata encoding layer inside the proposal description field, adds new voting-type options to the UI, clarifies UI copy for users, and ensures the results-calculation logic properly interprets embedded metadata.
The goal is to allow proposals to dynamically specify additional parameters—initially approval_threshold and quorum—while remaining backward compatible with existing proposal structures by falling back to existing defaults if left unspecified.
________________


2. Motivation & Goals
2.1 Problem
Current proposals do not include threshold/quorum metadata, forcing the system to use global or default rules. Users also lack contextual UI guidance for selecting majority types (simple majority, 2/3 super majority, etc.). There is no structured way to attach configuration data to the description field without modifying the underlying protocol.
2.2 Goals
   * Enable proposals to embed metadata into the proposal description field in a protocol-safe, backward-compatible, and UI-transparent manner.

   * Update creation screens to support selecting majority types.

   * Improve the voting results page to interpret proposal-specific thresholds.

   * Train internal governance stakeholders (steering committee) to reject incorrectly classified proposals.

________________


3. Functional Requirements
3.1 Description Field Encoding Schema
3.1.1 New Format:
The proposal description body will be overloaded with optional metadata using a deterministic encoding pattern:
[0x00][0x00][0x00][0x00][d1][d2]...<human-readable proposal text>...|key=value,key=value


Where:
      * Bytes 0–3: Four null bytes (0x00 0x00 0x00 0x00)

         * Used as a marker indicating enhanced decoding.

            * Bytes 4–5: An unsigned integer (0–65,535) representing the decoding version/technique.

               * Version 1 = 0x0001 (decimal 1)

                  * Remaining string: Normal plaintext body.

                  * Final metadata section: After the last | character, everything following conforms to:

                     * split on commas → key-value pairs

                     * split on = → key vs value

3.1.2 Supported Keys (v1):
Only the following keys are valid:
                        * approval_threshold

                        * quorum

3.1.3 Value Types
                           * Values are interpreted as strings, then cast to bigint (or equivalent) during decoding.

3.1.4 Example
<normal proposal body text> |approval_threshold=1000,quorum=1000


3.1.5 Error Handling
                              * If version byte mismatches a supported version → fall back to standard description behavior.

                              * If the metadata section is malformed (missing '=' or having unknown keys) → system logs a warning; UI displays defaults.

                              * If casting fails → treat as invalid; ignore corrupted key-values but continue normal UI rendering.

________________


3.2 UI Changes – Proposal Creation Screen
3.2.1 New Proposal Type Drop-Down Options
Extend the “Proposal Type” selector with:
                                 * Simple Majority

                                 * 2/3 Super Majority

Existing proposal types should remain.
3.2.2 UI Copy and Explanations
A new info block will be added to the creation screen:
                                    * Clear explanation of how simple majority vs 2/3 super-majority differ.

                                    * For each type, show:

                                       * definition

                                       * when to choose each

                                          * Copy to be provided by the governance/communications team.
  

3.2.3 Automatic Metadata Embedding
When the user selects a proposal type:
                                          * The front-end calculates the appropriate default metadata values (approval_threshold, quorum) or uses values supplied by the user (if configurable).

                                          * These are appended to the description field following the encoding schema.

                                          * The encoding process must be transparent—the user does not see raw encoded bytes or metadata.

3.2.4 Validation Before Submission
The UI must prevent final submission if required metadata cannot be encoded.
________________


3.3 Governance Workflow Alignment
3.3.1 Screening Committee Guidelines
                                             * The governance body (screening committee) will be trained to reject incorrect proposal types.

                                             * If a proposal is misclassified (e.g., user selected simple majority but intended super-majority), the committee should:


                                                * Inform the submitter to re-submit with the correct proposal type.

This ensures metadata integrity even if the UI is misused.
________________


3.4 Proposal Display & Results Calculation (UI)
3.4.1 Decoding Metadata for Display
Wherever proposal results are shown:
                                                   * The front-end must decode metadata from the description field.

                                                   * The interpreted approval_threshold and quorum should override global defaults.

3.4.2 Modifying Outcome Logic
                                                      * Outcome evaluation (pass/fail) must use metadata-derived thresholds.

                                                      * Edge case: If metadata is missing, fallback to legacy behavior.

3.4.3 Display to Users
The UI should show:
                                                         * The derived threshold/quorum values.

                                                         * The proposal type (inferred from metadata).

                                                         * What rules were used to compute the final outcome.

3.4.4 Backward Compatibility
Proposals created before this change:
                                                            * Will not contain null-byte prefix → decoder ignores metadata.

                                                            * Calculation uses default global logic.

________________


4. Non-Functional Requirements
4.1 Backward Compatibility
Legacy proposals and clients must continue functioning without modification.
4.2 Security
                                                               * Metadata must not allow code injection.

                                                               * Only recognized keys may affect logic.

4.3 Performance
Decoding must be O(n) relative to description length—negligible.
4.4 Auditability
Encoded metadata for each proposal should be clearly visible in raw description text (on-chain or logged), ensuring transparent auditability.
________________


5. Detailed Implementation Notes
5.1 Front-End Encoding Function
function encodeDescription(description, metadata, version=1) {
    const prefix = "\x00\x00\x00\x00"; // 4 null bytes
    const versionBytes = convertUInt16ToBytes(version); // 2 bytes
    const encodedMeta = "|" + serializeMetadata(metadata); 
    return prefix + versionBytes + description + encodedMeta;
}


5.2 Metadata Serialization
approval_threshold=1000,quorum=1000


5.3 Decoding Logic
                                                                  1. Check first 4 bytes = null. If not → return unmodified body.

                                                                  2. Read bytes 4–5 = version.

                                                                  3. Strip final |… chunk.

                                                                  4. Split on , → pairs.

                                                                  5. Split each pair on = → key/value.

                                                                  6. Cast each value to bigint.

5.4 UI Integration
                                                                     * Drop-down selection triggers metadata generation logic.

                                                                     * Explanation tooltip component added.

5.5 Governance Integration
                                                                        * Screening committee SOP updated.

                                                                        * Should not be system-enforced; governance-level enforcement only.

________________


6. Edge Cases
                                                                           * Missing metadata after | → ignore metadata.

                                                                           * Multiple | present → use last one only.

                                                                           * Unknown keys → ignore.

                                                                           * User manually edits description → UI must still encode metadata after user-provided text.

                                                                           * Metadata colliding with normal user text containing | → handled by taking only the last delimiter.

                                                                           * Multi-byte strings in values → allowed, but not recommended.

________________


7. Dependencies
                                                                              * Front-end team for encoder/decoder.

                                                                              * Governance/communications team for educational text.

                                                                              * Screening committee for process alignment.

                                                                              * QA for UI correctness and backward-compatibility testing.

________________


8. Success Criteria
A successful implementation will allow:
                                                                                 1. Users to create proposals with correct majority types in one action.

                                                                                 2. Threshold/quorum values to be unambiguously stored and retrievable.

                                                                                 3. The proposal results screen to compute outcomes using metadata.

                                                                                 4. Governance workflows to operate smoothly with the new metadata standard.

                                                                                 5. No regression or breakage of legacy proposals.

                                                                                 6. Clarity for anyone visiting https://gov.houseofstake.org/proposals and https://gov.houseofstake.org/proposals/17 if a proposal passed, what voting mechanism was applied and if quorum was met.